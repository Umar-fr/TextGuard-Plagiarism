Adding to the above answers: Suppose you have a a class named "myPackage.MyClass". Assuming that is in classpath, the following statements are equivalent. //checking class name using string comparison, only Runtime check possible if(myInstance.getClass().getName().equals(Class.forName("myPackage.MyClass")).getName()){} //checking actual Class object for equality, only Runtime check possible if(myInstance.getClass().getName() == Class.forName("myPackage.MyClass"))){} //checking actual Class object for equality, but compile time validation //will ensure MyClass is in classpath. Hence this approach is better (according to fail-fast paradigm) if(myInstance.getClass() == MyClass.class){} Similarly, the following are also equivalent. Class<?> myClassObject = MyClass.class; //compile time check Class<?> myClassObject = Class.forname("myPackage.MyClass"); //only runtime check If JVM loads a type, a class object representing that type will be present in JVM. we can get the metadata regarding the type from that class object which is used very much in reflection package. MyClass.class is a shorthand method which actually points to the Class object representing MyClass. As an addendum, some information about Class<?> reference which will be useful to read along with this as most of the time, they are used together. Class<?> reference type can hold any Class object which represents any type. This works in a similar fashion if the Class<?> reference is in method argument as well. Please note that the class "Class" does not have a public constructor. So you cannot instantiate "Class" instances with "new" operator.