typeid is a keyword, not a function, so it need not and cannot be declared. It cannot be a function, since then the expression typeid(T) where T is a type would not be valid. It is implemented in the compiler, not in the library. typeinfo doesn't need to have any data members; its name method is allowed to serve strings from what is effectively a static array of them. For example, consider this simple class that knows its own name: // foo.h class Foo { // look ma, no data members! public: char const *name() const; }; // foo.cpp char const NAME[] = "Foo"; char const *Foo::name() const { return NAME; } Apart from name , the main operation on typeinfo objects is == , which can be implemented by a simple pointer comparison between the objects; in that case, the compiler could construct a big typeinfo [] array somewhere private and typeid would just index into that array to fetch the right typeinfo object. How it works, however, is implementation-dependent.